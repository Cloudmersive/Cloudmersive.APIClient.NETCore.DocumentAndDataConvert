/* 
 * convertapi
 *
 * Convert API lets you effortlessly convert file formats and types.
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using SwaggerDateConverter = Cloudmersive.APIClient.NETCore.DocumentAndDataConvert.Client.SwaggerDateConverter;

namespace Cloudmersive.APIClient.NETCore.DocumentAndDataConvert.Model
{
    /// <summary>
    /// A content run in a Word Document (DOCX) file
    /// </summary>
    [DataContract]
    public partial class DocxRun :  IEquatable<DocxRun>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DocxRun" /> class.
        /// </summary>
        /// <param name="runIndex">Index of the run, 0-based.</param>
        /// <param name="path">The Path of the location of this object; leave blank for new tables.</param>
        /// <param name="textItems">Text items inside the run; this is where the actual text content is stored.</param>
        /// <param name="bold">True to make the text bold, false otherwise.</param>
        /// <param name="italic">True to make the text italic, false otherwise.</param>
        /// <param name="underline">Underline mode for the text; possible values are: Words, Double, Thick, Dotted, DottedHeavy, Dash, DashedHeavy, DashLong, DashLongHeavy, DotDash, DashDotHeavy, DotDotDash, DashDotDotHeavy, Wave, WavyHeavy, WavyDouble, None.</param>
        /// <param name="fontFamily">Font Family name for the text, e.g. \&quot;Arial\&quot; or \&quot;Times New Roman\&quot;.</param>
        /// <param name="fontSize">Font size in font points (e.g. \&quot;24\&quot;).</param>
        public DocxRun(int? runIndex = default(int?), string path = default(string), List<DocxText> textItems = default(List<DocxText>), bool? bold = default(bool?), bool? italic = default(bool?), string underline = default(string), string fontFamily = default(string), string fontSize = default(string))
        {
            this.RunIndex = runIndex;
            this.Path = path;
            this.TextItems = textItems;
            this.Bold = bold;
            this.Italic = italic;
            this.Underline = underline;
            this.FontFamily = fontFamily;
            this.FontSize = fontSize;
        }
        
        /// <summary>
        /// Index of the run, 0-based
        /// </summary>
        /// <value>Index of the run, 0-based</value>
        [DataMember(Name="RunIndex", EmitDefaultValue=false)]
        public int? RunIndex { get; set; }

        /// <summary>
        /// The Path of the location of this object; leave blank for new tables
        /// </summary>
        /// <value>The Path of the location of this object; leave blank for new tables</value>
        [DataMember(Name="Path", EmitDefaultValue=false)]
        public string Path { get; set; }

        /// <summary>
        /// Text items inside the run; this is where the actual text content is stored
        /// </summary>
        /// <value>Text items inside the run; this is where the actual text content is stored</value>
        [DataMember(Name="TextItems", EmitDefaultValue=false)]
        public List<DocxText> TextItems { get; set; }

        /// <summary>
        /// True to make the text bold, false otherwise
        /// </summary>
        /// <value>True to make the text bold, false otherwise</value>
        [DataMember(Name="Bold", EmitDefaultValue=false)]
        public bool? Bold { get; set; }

        /// <summary>
        /// True to make the text italic, false otherwise
        /// </summary>
        /// <value>True to make the text italic, false otherwise</value>
        [DataMember(Name="Italic", EmitDefaultValue=false)]
        public bool? Italic { get; set; }

        /// <summary>
        /// Underline mode for the text; possible values are: Words, Double, Thick, Dotted, DottedHeavy, Dash, DashedHeavy, DashLong, DashLongHeavy, DotDash, DashDotHeavy, DotDotDash, DashDotDotHeavy, Wave, WavyHeavy, WavyDouble, None
        /// </summary>
        /// <value>Underline mode for the text; possible values are: Words, Double, Thick, Dotted, DottedHeavy, Dash, DashedHeavy, DashLong, DashLongHeavy, DotDash, DashDotHeavy, DotDotDash, DashDotDotHeavy, Wave, WavyHeavy, WavyDouble, None</value>
        [DataMember(Name="Underline", EmitDefaultValue=false)]
        public string Underline { get; set; }

        /// <summary>
        /// Font Family name for the text, e.g. \&quot;Arial\&quot; or \&quot;Times New Roman\&quot;
        /// </summary>
        /// <value>Font Family name for the text, e.g. \&quot;Arial\&quot; or \&quot;Times New Roman\&quot;</value>
        [DataMember(Name="FontFamily", EmitDefaultValue=false)]
        public string FontFamily { get; set; }

        /// <summary>
        /// Font size in font points (e.g. \&quot;24\&quot;)
        /// </summary>
        /// <value>Font size in font points (e.g. \&quot;24\&quot;)</value>
        [DataMember(Name="FontSize", EmitDefaultValue=false)]
        public string FontSize { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class DocxRun {\n");
            sb.Append("  RunIndex: ").Append(RunIndex).Append("\n");
            sb.Append("  Path: ").Append(Path).Append("\n");
            sb.Append("  TextItems: ").Append(TextItems).Append("\n");
            sb.Append("  Bold: ").Append(Bold).Append("\n");
            sb.Append("  Italic: ").Append(Italic).Append("\n");
            sb.Append("  Underline: ").Append(Underline).Append("\n");
            sb.Append("  FontFamily: ").Append(FontFamily).Append("\n");
            sb.Append("  FontSize: ").Append(FontSize).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as DocxRun);
        }

        /// <summary>
        /// Returns true if DocxRun instances are equal
        /// </summary>
        /// <param name="input">Instance of DocxRun to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(DocxRun input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.RunIndex == input.RunIndex ||
                    (this.RunIndex != null &&
                    this.RunIndex.Equals(input.RunIndex))
                ) && 
                (
                    this.Path == input.Path ||
                    (this.Path != null &&
                    this.Path.Equals(input.Path))
                ) && 
                (
                    this.TextItems == input.TextItems ||
                    this.TextItems != null &&
                    this.TextItems.SequenceEqual(input.TextItems)
                ) && 
                (
                    this.Bold == input.Bold ||
                    (this.Bold != null &&
                    this.Bold.Equals(input.Bold))
                ) && 
                (
                    this.Italic == input.Italic ||
                    (this.Italic != null &&
                    this.Italic.Equals(input.Italic))
                ) && 
                (
                    this.Underline == input.Underline ||
                    (this.Underline != null &&
                    this.Underline.Equals(input.Underline))
                ) && 
                (
                    this.FontFamily == input.FontFamily ||
                    (this.FontFamily != null &&
                    this.FontFamily.Equals(input.FontFamily))
                ) && 
                (
                    this.FontSize == input.FontSize ||
                    (this.FontSize != null &&
                    this.FontSize.Equals(input.FontSize))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.RunIndex != null)
                    hashCode = hashCode * 59 + this.RunIndex.GetHashCode();
                if (this.Path != null)
                    hashCode = hashCode * 59 + this.Path.GetHashCode();
                if (this.TextItems != null)
                    hashCode = hashCode * 59 + this.TextItems.GetHashCode();
                if (this.Bold != null)
                    hashCode = hashCode * 59 + this.Bold.GetHashCode();
                if (this.Italic != null)
                    hashCode = hashCode * 59 + this.Italic.GetHashCode();
                if (this.Underline != null)
                    hashCode = hashCode * 59 + this.Underline.GetHashCode();
                if (this.FontFamily != null)
                    hashCode = hashCode * 59 + this.FontFamily.GetHashCode();
                if (this.FontSize != null)
                    hashCode = hashCode * 59 + this.FontSize.GetHashCode();
                return hashCode;
            }
        }
    }

}
